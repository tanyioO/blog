<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tanyioO</title>
  
  <subtitle>哦嚯</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://tanyioo.github.io/blog/"/>
  <updated>2019-07-11T01:08:28.197Z</updated>
  <id>https://tanyioo.github.io/blog/</id>
  
  <author>
    <name>tanyioO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用ShouldComponentUpdate避免重复渲染</title>
    <link href="https://tanyioo.github.io/blog/2019/07/08/ShouldComponentUpdate/"/>
    <id>https://tanyioo.github.io/blog/2019/07/08/ShouldComponentUpdate/</id>
    <published>2019-07-08T01:58:08.000Z</published>
    <updated>2019-07-11T01:08:28.197Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在开发一个带有Echarts图表的页面时，每次切换图表类型，都会出现图表反复渲染的问题。通常情况下，页面多次渲染并不会影响用户体验（如果没有动画效果），而在这个页面下Echarts数据填充的动画反复进行多次就会让人明显的感觉到页面在多次刷新，降低用户体验。问题代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleChangeDisplayType = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="comment">// 获取echarts图表数据</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">'securitySystem/fetchSpaceAlarmData'</span> &#125;);</span><br><span class="line">  <span class="comment">// 受控组件Button.Group，需手动改变state中的值</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">displayType</span>: e.target.value &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; spaceAlarmData &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'parking_space_alarm'</span>)</span><br><span class="line">  echarts.dispose(el);</span><br><span class="line">  <span class="keyword">this</span>.parkingSpaceAlarmChart = echarts.init(el);</span><br><span class="line">  <span class="comment">// 渲染图表组件</span></span><br><span class="line">  <span class="keyword">this</span>.renderSpaceAlarmChart(spaceAlarmData, <span class="keyword">this</span>.parkingSpaceAlarmChart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>页面涉及到多个图表类型之间的切换，所以需要在每次切换时请求数据并手动保存目标图表类型。本以为多次渲染echarts图表的<code>dispose</code>和<code>init</code>同步渲染引起的，在后来仔细了解了React生命周期发现<code>state</code>和<code>props</code>的异步过程不会合并到一次页面渲染，会依次进行。</p><h4 id="页面渲染的触发时机"><a href="#页面渲染的触发时机" class="headerlink" title="页面渲染的触发时机"></a>页面渲染的触发时机</h4><p>页面重新渲染，需要触发React生命周期中的Render函数，以下的React生命周期图可便于理解Render函数是如何被触发的：</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/shouldComponentUpdate/react_lifecycle.png" alt="react_lifecycle"></p><p>这张图将React生命周期分成了三个阶段：生成期、存在期、销毁期。由图可以比较清楚的看出触发Render函数的内容可能包括：</p><ul><li>生成期初次Render</li><li>Props变更</li><li>State变更</li></ul><p>在React的渲染机制中，组件内的某一个props或state变化，会导致该组件内的所有子组件都重写render函数，尽管绝大多数子组件的props没有变化。例如在上面的问题中，受控组件Button.Group和Echarts图表作为页面的子组件，当页面内非自身状态更新时该子组件也会重新渲染。</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/shouldComponentUpdate/target.png" alt="target"></p><p>例如在项目中，点击切换图表类型的主要目的是想设置页面上某一个按钮为选中状态，只需要更新页面上Button.Group中相应的DOM即可。事实上在更新Button组件状态时，还触发了图表组件的Render函数，当父组件中用于填充图表数据的props更新时，再次触发该组件内所有子组件的重绘，因此才会发生问题当中所描述的图表动画加载到一半页面刷新再次触发图表动画的过程。</p><h4 id="使用ShouldComponentUpdate避免重复触发Render函数"><a href="#使用ShouldComponentUpdate避免重复触发Render函数" class="headerlink" title="使用ShouldComponentUpdate避免重复触发Render函数"></a>使用ShouldComponentUpdate避免重复触发Render函数</h4><p><strong>shouldComponentUpdate(nextProps, nextState)</strong></p><p>当 props 或 state 发生变化时，<code>shouldComponentUpdate</code> 会在渲染执行之前被调用。返回值默认为 true。首次渲染(<code>ComponentDidMount</code>前的<code>Render</code>)或使用 <code>forceUpdate</code> 时不会调用该方法。</p><p>手动重写这个函数时，可以将 <code>this.props</code> 与 <code>nextProps</code> 以及 <code>this.state</code> 与<code>nextState</code> 进行比较，并返回<code>true</code>或 <code>false</code> 以告知 React 是否需要跳过更新。需要注意的是，<strong>返回 <code>false</code> 并不会阻止子组件在 state 更改时重新渲染。</strong></p><blockquote><p>这里的子组件是自身还是父组件下的所有子组件还不太清楚。</p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener">官方</a>的解释是：目前，如果 <code>shouldComponentUpdate</code> 返回 <code>false</code>，则不会调用 <a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillupdate" target="_blank" rel="noopener"><code>UNSAFE_componentWillUpdate</code></a>，<a href="https://zh-hans.reactjs.org/docs/react-component.html#render" target="_blank" rel="noopener"><code>render</code></a> 和 <a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate" target="_blank" rel="noopener"><code>componentDidUpdate</code></a>。后续版本，React 可能会将 <code>shouldComponentUpdate</code> 视为提示而不是严格的指令，并且，当返回 <code>false</code> 时，仍可能导致组件重新渲染。</p><p>官方建议此方法仅作为性能优化的方式而存在。不能依靠此方法来“阻止”渲染，因为这可能会产生 bug，应该考虑使用内置的 PureComponent 组件，而不是手动编写 <code>shouldComponentUpdate</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p></blockquote><p>在项目中遇到的问题暂时可以使用如下方式解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; displayType &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">  <span class="comment">// 改变state的时候不更新图表组件，改变props的时候更新</span></span><br><span class="line">  <span class="keyword">if</span> (displayType === nextState.displayType) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React.PureComponent</strong></p><p><code>React.PureComponent</code> 与 <code>React.Component</code> 几乎完全相同，但 <code>React.PureComponent</code> 通过<code>props</code>和<code>state</code>的<strong>浅对比</strong>来实现 <code>shouldComponentUpate</code>。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）。</p><blockquote><ul><li>无论组件是否是 <code>PureComponent</code>，如果定义了<code>shouldComponentUpdate</code>，那么会调用它并以它的执行结果来判断是否 update。只有在组件未定义 <code>shouldComponentUpdate</code> 的情况下，才会判断该组件是否是 <code>PureComponent</code>。如果是的话，则会对新旧 props、state 进行 <a href="https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js#L39" target="_blank" rel="noopener">shallowEqual</a> 比较。</li><li>浅对比，只会比较到两个对象的 hasOwnProperty 是否符合<code>Object.keys()</code>判等，不会递归地去深层比较。</li></ul></blockquote><p>在项目中，由于图表数据使用嵌套数组的数据结构，无法简单的使用<code>PureComponent</code>来进行优化，如果需要兼顾复杂的数据结构以及较好的用户体验，可以使用第三方库如immutable.js来进行优化，此处不做涉及。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用<code>ShouldComponent</code>作为页面性能的一种方式，能够有效的避免页面重复渲染的问题，从而提升用户体验。作为一个不常用的React生命周期钩子，在之前的项目开发中没能很好的理解并运用。希望能通过写文章的方式记录自己学习和了解其原理的过程，加深对于React相关知识的理解。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;在开发一个带有Echarts图表的页面时，每次切换图表类型，都会出现图表反复渲染的问题。通常情况下，页面多次渲染并不会影响用户体验（如果没有动画效果），而在这个页面下Echarts数据填充的动画反复进行多次就会让人明显的感觉到页面在多次刷新，降低用户体验。问题代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;handleChangeDisplayType = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; dispatch &amp;#125; = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 获取echarts图表数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dispatch(&amp;#123; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;securitySystem/fetchSpaceAlarmData&#39;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 受控组件Button.Group，需手动改变state中的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setState(&amp;#123; &lt;span class=&quot;attr&quot;&gt;displayType&lt;/span&gt;: e.target.value &amp;#125;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;componentDidUpdate() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; spaceAlarmData &amp;#125; = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; el = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;parking_space_alarm&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echarts.dispose(el);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.parkingSpaceAlarmChart = echarts.init(el);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 渲染图表组件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.renderSpaceAlarmChart(spaceAlarmData, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.parkingSpaceAlarmChart);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://tanyioo.github.io/blog/categories/React/"/>
    
    
      <category term="React生命周期" scheme="https://tanyioo.github.io/blog/tags/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>ant-modal中forceRender属性及其作用</title>
    <link href="https://tanyioo.github.io/blog/2019/06/24/ant-modal/"/>
    <id>https://tanyioo.github.io/blog/2019/06/24/ant-modal/</id>
    <published>2019-06-24T08:27:55.000Z</published>
    <updated>2019-07-10T12:11:41.605Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><h4 id="ant-modal-forceRender"><a href="#ant-modal-forceRender" class="headerlink" title="ant-modal/forceRender"></a>ant-modal/forceRender</h4><p>以下是<a href="https://ant.design/index-cn" target="_blank" rel="noopener">ant design</a>对于对话框的使用场景介绍：需要用户处理事务，又不希望跳转页面以致打断工作流程时，可以使用 modal 在当前页面正中打开一个浮层，承载相应的操作。对话框可细分成两类：模态对话框和非模态对话框。模态对话框会阻断应用程序，如果出现，直到对话框关闭，则其是应用程序当前唯一活动的东西；非模态对话框不会阻断应用程序，因此同时可以有多个非模态的对话框被激活。ant-modal是其组件库中的模态对话框，与之类似如bootstrap-modal也是模态对话框。</p><p>ant-modal属性<code>forceRender</code>属性的主要作用是：无论modal是隐藏或者显示，都会强制性的将modal渲染到DOM中，以满足在实际开发过程中的一些需求，例如：在进入modal前，提前获取到模态框中的DOM元素，作为图片加载容器，从而解决在网络环境较差时打开modal图片加载缓慢的问题。</p><a id="more"></a><h4 id="强制渲染-or-not？"><a href="#强制渲染-or-not？" class="headerlink" title="强制渲染 or not？"></a>强制渲染 or not？</h4><p>在我所使用的一些”历史比较悠久”的UI组件库如bootstrap、layUI中，对于modal的处理是将其作为一个绝对定位元素渲染到DOM中，设置它的CSS display属性用于控制其显示和隐藏。这种方式在现在的”数据驱动“式开发中存在很多问题，例如：</p><ul><li>首屏加载问题：当modal中包含数据请求时，数据量较大或者页面中的modal个数比较多时，可能会导致页面加载缓慢。</li><li>数据“残留”：如果某个操作表格列中包含modal，那么所有的表格行使用的其实是同一个modal。当modal中存在表单时，由于modal只是隐藏，并不销毁，再次打开modal时，表单中的数据为上一次修改的数据，需要在关闭modal时手动清除或重置表单。</li></ul><p>所以，一开始大佬们在开发<a href="https://github.com/react-component/dialog" target="_blank" rel="noopener">rc-dialog</a>的时候考虑到了强制渲染所带来的问题，为此做了优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="keyword">this</span>.getWrapStyle();</span><br><span class="line"><span class="comment">// clear hide display</span></span><br><span class="line"><span class="comment">// and only set display after async anim, not here for hide</span></span><br><span class="line"><span class="keyword">if</span> (props.visible) &#123;</span><br><span class="line">  style.display = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ant-modal是基于rc-dialog封装的对话框组件（contributors是同一批大佬），因此7.3.0前的版本也就天生携带“不可见时不渲染”的属性。这种优化在一定程度上比较完美地解决上述问题，首先，modal在父节点挂载时不渲染，不会对首屏加载造成压力；同时，关闭modal时将其进行销毁，那么下一次打开的就是一个新的modal，从而解决了数据残留的问题。</p><p>当然，并不是所有的改变都是百利而无一害的。在实际开发时这种“强制不渲染”带来的问题就是：<strong>无法在父组件挂载时拿到modal中的子元素</strong>。然而在某些情况下在父组件挂载时提前获取modal中的子元素是很有必要的操作。</p><p>于是有开发者提了<a href="https://github.com/ant-design/ant-design/issues/12503" target="_blank" rel="noopener">issue #12503</a>：</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/ant-modal/issue.png" alt="issue"></p><p>由此引发了ant design维护者大佬们的一番“激烈”的讨论，最终的讨论结果就是：合并之前开发者提交到rc-dialog的<a href="https://github.com/react-component/dialog/commit/f9a7c2169df21f521dcae57a568adcad08b192b2" target="_blank" rel="noopener">pull request</a>，添加<code>forceRender</code>属性，让开发者可以根据实现情况决定是否需要强制渲染。（撒花）</p><p>PR的实现原理是根据<code>props.forceRender</code>属性值，来判断应该设置<code>display</code>属性值为<code>none</code>或者<code>null</code>，源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="keyword">this</span>.getWrapStyle();</span><br><span class="line"><span class="comment">// clear hide display</span></span><br><span class="line"><span class="comment">// and only set display after async anim, not here for hide</span></span><br><span class="line"><span class="comment">// if the forceRender is true, change display value to none</span></span><br><span class="line"><span class="keyword">if</span> (props.forceRender &amp;&amp; !props.visible) &#123;</span><br><span class="line">  style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.visible) &#123;</span><br><span class="line">  style.display = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rc-dialog 7.3.0及以后版本，and design 3.12.0及以后版本，正式支持<code>forceRender</code>属性。</p><h4 id="关注及使用"><a href="#关注及使用" class="headerlink" title="关注及使用"></a>关注及使用</h4><p>rc-dialog 7.3.0更新于2018年12月，在这之前在项目开发中遇到过这样一个使用场景：打开modal，使用ActiveX插件播放视频。在播放视频之前，需要拿到modal中的子元素&lt;object>标签。</p><blockquote><p>&lt;object>标签定义一个嵌入的对象。比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。</p></blockquote><p>提前拿到&lt;object>标签的主要原因是为了在父元素挂载后就开始对ActiveX插件进行初始化及后台登录等操作，如果等到ant-modal渲染以后再执行以上操作，就会出现明显的卡顿现象，十分影响用户体验。在<code>forceRender</code>没有实现之前，受开发进度影响，只能退而求其次的使用layUI组件库的对话框layer作为视频播放对话框的载体。</p><p>2019年1月6日，ant design更新<code>forceRender</code>属性以后，我马上对项目中的组件进行了替换，然而即使添加了<code>forceRender</code>属性，也无法拿到modal中的子元素。在提了一个<a href="https://github.com/ant-design/ant-design/issues/14160" target="_blank" rel="noopener">issue #14160</a>以后，发现是ant design维护者的疏忽，只更新了API文档却没在interface里面添加新属性。在解决上述问题以后，依然无法按照预期拿到DOM元素，官方为此提供了一个<a href="https://codesandbox.io/s/xv68643y14" target="_blank" rel="noopener">demo</a>，里面使用了<code>requestAnimationFrame</code>这个<code>Web API</code>，有关知识可以查看另一篇文章。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不管是简单还是复杂的问题，追本溯源或者仔细分解以后其实都是由各种小问题导致的。在不了解具体实现时，我会认为<code>forceRender</code>的原理必定是很复杂，需要多方面考虑的。在看了ts的源码以后会觉得大佬们确实很厉害，只是利用CSS的display属性就实现页面优化或者API的设计，简单并且优雅。</p><p>学习代码是一种快乐，一步一步由浅到深具体地去了解造轮子的过程更是一种快乐。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;h4 id=&quot;ant-modal-forceRender&quot;&gt;&lt;a href=&quot;#ant-modal-forceRender&quot; class=&quot;headerlink&quot; title=&quot;ant-modal/forceRender&quot;&gt;&lt;/a&gt;ant-modal/forceRender&lt;/h4&gt;&lt;p&gt;以下是&lt;a href=&quot;https://ant.design/index-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ant design&lt;/a&gt;对于对话框的使用场景介绍：需要用户处理事务，又不希望跳转页面以致打断工作流程时，可以使用 modal 在当前页面正中打开一个浮层，承载相应的操作。对话框可细分成两类：模态对话框和非模态对话框。模态对话框会阻断应用程序，如果出现，直到对话框关闭，则其是应用程序当前唯一活动的东西；非模态对话框不会阻断应用程序，因此同时可以有多个非模态的对话框被激活。ant-modal是其组件库中的模态对话框，与之类似如bootstrap-modal也是模态对话框。&lt;/p&gt;
&lt;p&gt;ant-modal属性&lt;code&gt;forceRender&lt;/code&gt;属性的主要作用是：无论modal是隐藏或者显示，都会强制性的将modal渲染到DOM中，以满足在实际开发过程中的一些需求，例如：在进入modal前，提前获取到模态框中的DOM元素，作为图片加载容器，从而解决在网络环境较差时打开modal图片加载缓慢的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="UI组件库" scheme="https://tanyioo.github.io/blog/categories/UI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
    
      <category term="ant-modal" scheme="https://tanyioo.github.io/blog/tags/ant-modal/"/>
    
  </entry>
  
  <entry>
    <title>JSON序列化与嵌套字符串中引号的转义</title>
    <link href="https://tanyioo.github.io/blog/2019/06/21/JSONAndString/"/>
    <id>https://tanyioo.github.io/blog/2019/06/21/JSONAndString/</id>
    <published>2019-06-21T01:14:34.000Z</published>
    <updated>2019-07-11T01:03:59.097Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果需要发给后台一个标准的<code>JSON数组</code>，通常情况下使用<code>JSON.stringify()</code>对数组进行序列化即可，如果数组比较简单，也可以使用引号手动拼接。在项目开发过程中遇到过这样一个问题，在手动拼接<code>JSON数组</code>后，经过<a href="https://github.com/umijs/umi-request" target="_blank" rel="noopener">umi-request</a>的自动序列化与反序列化，最终发送的请求参数却不是一个可识别的标准<code>JSON数组</code>，而是一个字符串。主要原因在于：对嵌套字符串进行序列化和反序列化时，有可能会将字符串中的引号进行转义，如果拼接的字符串格式不正确，就会出现无法转义的情况，最终只能得到一个字符串而不是<code>JSON数组</code>。</p><a id="more"></a><h4 id="字符串中的单-双引号"><a href="#字符串中的单-双引号" class="headerlink" title="字符串中的单/双引号"></a>字符串中的单/双引号</h4><p>在讨论上面的问题前，先看一字符串的单引号和双引号的区别。在JavaScript中单引号和双引号可以同时使用，混合使用时要遵循一定的准则：</p><ul><li>双引号<code>&quot;&quot;</code>中可以嵌套单引号<code>&#39;&#39;</code></li><li>单引号<code>&#39;&#39;</code>中可以嵌套双引号<code>&quot;&quot;</code></li><li>双引号中也可以嵌套双引号，但必须使用转义<code>\&quot;</code></li><li>单引号中也可以嵌套单引号，但必须使用转义<code>\&#39;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'JavaScript "is" awesome'</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"JavaScript 'is' awesome"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"JavaScript \"is\" awesome"</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="string">"JavaScript "</span>is<span class="string">" awesome"</span>; <span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="string">'JavaScript \'is\' awesome'</span>; </span><br><span class="line"><span class="keyword">var</span> f = <span class="string">'JavaScript '</span>is<span class="string">' awesome'</span>; <span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="string">"J\"a\'v\'\"aScript \'is\' awesome"</span>; <span class="comment">// "J"a'v'"aScript 'is' awesome"</span></span><br></pre></td></tr></table></figure><p>理论上来说，不同类型引号之间可以通过转义无限嵌套，但由于可读性太差，一般不建议这么做。</p><h4 id="JSON序列化和反序列化时出现的问题"><a href="#JSON序列化和反序列化时出现的问题" class="headerlink" title="JSON序列化和反序列化时出现的问题"></a>JSON序列化和反序列化时出现的问题</h4><p>回到一开始在项目中遇到的问题，如果使用嵌套字符串手动拼接<code>JSON数组</code>，应该如何使用？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单引号内嵌套双引号</span></span><br><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'camera/fetchCameraGroups'</span>,</span><br><span class="line">  payload: <span class="string">'["salvo"]'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/JSONAndString/request1.png" alt="request"></p><p>这个结果正好是想要的标准<code>json数组</code>。</p><p>换另外一种形式，在双引号内嵌套单引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双引号内嵌套单引号</span></span><br><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'camera/fetchCameraGroups'</span>,</span><br><span class="line">  payload: <span class="string">"['salvo']"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>request payload则是：</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/JSONAndString/request2.png" alt="request"></p><p>从结果上看来，请求参数是一个<code>JSON字符串</code>而不是<code>JSON数组</code>。</p><p>通过上面讲述的字符串嵌套规则，在两种方式都支持的情况下，出现问题的原因应该在于umi-request的JSON自动序列化与反序列化中的某一过程。</p><h4 id="部分猜测及验证"><a href="#部分猜测及验证" class="headerlink" title="部分猜测及验证"></a>部分猜测及验证</h4><p>根据以上猜测，直接使用<code>JSON.stringify()</code>和<code>JSON.parse()</code>进行验证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">JSON</span>.stringify(<span class="string">'["salvo"]'</span>); <span class="comment">// ""[\"salvo\"]""</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(a); <span class="comment">// "["salvo"]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.stringify(<span class="string">"['salvo']"</span>); <span class="comment">// ""['salvo']""</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(b); <span class="comment">// "['salvo']"</span></span><br></pre></td></tr></table></figure><p>以上可以看出，JSON序列化<code>&#39;[&quot;salvo&quot;]&#39;</code>时，首先将内层的双引号转义，然后将外层的单引号序列化为双引号，以便反序列化时正确解析；在序列化<code>&quot;[&#39;salvo&#39;]&quot;</code>时，由于内层使用单引号不符合标准的<code>JSON数组</code>格式，因此没有对其进行转义或者其他处理，然后将双引号包裹的内容当成了一个完整的字符串。至于在序列化和反序列化时，解析内外层的顺序，使用<a href="https://github.com/facebook/react/blob/master/scripts/prettier/index.js" target="_blank" rel="noopener">umi内置的格式化标准</a>以及<a href="https://prettier.io/docs/en/api.html" target="_blank" rel="noopener">prettier</a>工具验证如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"[\"salvo\"]” // '["</span>salvo<span class="string">"]'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'[\'salvo\']' // "</span>[<span class="string">'salvo'</span>]<span class="string">"</span></span><br></pre></td></tr></table></figure><p>可以看出prettier在格式化时，会以内层的引号类型为准，然后在外层采用不同的类型。</p><h4 id="结论及疑问"><a href="#结论及疑问" class="headerlink" title="结论及疑问"></a>结论及疑问</h4><p>JSON序列化与反序列化时，遵循的是<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-json-object" target="_blank" rel="noopener">ECMA262的相关标准</a>，在操作嵌套字符串时是根据JavaScript来具体实现的。因此在使用字符串拼接<code>JSON数组</code>时，不仅要符合字符串的嵌套规则，更要遵循JSON的标准数据格式。</p><p>当然，为防止这种问题的出现，应当直接使用<code>JSON.stringify()</code>创建<code>JSON数组</code>，避免偷懒直接使用字符串进行拼接。</p><p>疑问在于：从结果上看，JSON的序列化/反序列化与嵌套字符串使用prettier格式化后的效果是相同的，至于是不是对于相同标准的不同实现，我暂时还没有找到相关的资料并验证。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;如果需要发给后台一个标准的&lt;code&gt;JSON数组&lt;/code&gt;，通常情况下使用&lt;code&gt;JSON.stringify()&lt;/code&gt;对数组进行序列化即可，如果数组比较简单，也可以使用引号手动拼接。在项目开发过程中遇到过这样一个问题，在手动拼接&lt;code&gt;JSON数组&lt;/code&gt;后，经过&lt;a href=&quot;https://github.com/umijs/umi-request&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;umi-request&lt;/a&gt;的自动序列化与反序列化，最终发送的请求参数却不是一个可识别的标准&lt;code&gt;JSON数组&lt;/code&gt;，而是一个字符串。主要原因在于：对嵌套字符串进行序列化和反序列化时，有可能会将字符串中的引号进行转义，如果拼接的字符串格式不正确，就会出现无法转义的情况，最终只能得到一个字符串而不是&lt;code&gt;JSON数组&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://tanyioo.github.io/blog/categories/JavaScript/"/>
    
    
      <category term="JSON序列化" scheme="https://tanyioo.github.io/blog/tags/JSON%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="嵌套字符串的转义" scheme="https://tanyioo.github.io/blog/tags/%E5%B5%8C%E5%A5%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>IE下GET请求缓存问题及解决方案</title>
    <link href="https://tanyioo.github.io/blog/2018/11/29/IE%E4%B8%8B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>https://tanyioo.github.io/blog/2018/11/29/IE下缓存问题/</id>
    <published>2018-11-29T06:21:53.000Z</published>
    <updated>2019-07-11T01:47:38.949Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><h4 id="什么是浏览器缓存，为什么要使用它？"><a href="#什么是浏览器缓存，为什么要使用它？" class="headerlink" title="什么是浏览器缓存，为什么要使用它？"></a>什么是浏览器缓存，为什么要使用它？</h4><p> 缓存游走于服务器和客户端之间。服务器可能是源服务器（存放请求资源的服务器），也可能是反向代理服务器（如 Nginx），数量为 1 个或多个；客户端可能为 PC 端、移动端等，数量也为 1 个或多个。简单的说，缓存用于监控服务器与客户端之间的通信，监控客户端请求，并且把请求输出的内容（如页面、 图片和文件）拷贝一份副本存在本地；然后，如果下一个请求是相同的 URL，则直接请求保存的副本，而不用再次向服务器获取。</p><a id="more"></a><p>使用缓存的 3 个主要原因：</p><ul><li>提升访问速度：缓存离客户端更近，因此，从缓存请求数据比从服务器所用时间更少，显著地提高了网站的访问速度。</li><li>减少网络带宽消耗：副本被重复使用，降低请求次数，从而减少网络流量，节省运营成本。</li><li>降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力</li></ul><h4 id="浏览器缓存规则"><a href="#浏览器缓存规则" class="headerlink" title="浏览器缓存规则"></a>浏览器缓存规则</h4><p> 对于浏览器端的缓存来讲，这些规则是在 HTTP 协议头和 HTML 页面的 Meta 标签中定义的，分别<strong>新鲜度</strong>和<strong>校验值</strong>两个维度来确定浏览器是以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。</p><ul><li><p>新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的：</p><blockquote><p>(1) 含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内；<br>(2) 浏览器已经使用过这个缓存副本，并且在首次请求中已经检查过有效性（非首次请求）；</p></blockquote><p>满足以上两个情况的一种，浏览器会直接从缓存中获取副本并渲染。</p></li><li><p>校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，服务器需重新返回资源内容。</p></li></ul><p>浏览器请求流程图如下：</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/ie/cache.png" alt="cache"></p><blockquote><p>请求本地缓存过后，浏览器会向服务端发起请求，协商是否使用缓存，如果上一次的缓存中有 Last-modified 和 Etag 字段，浏览器将在 request header 中加入 If-Modified-Since（对应于 Last-modified）， 和 If-None-Match（对应于 Etag）。</p></blockquote><p> 两个概念：</p><ul><li>强缓存：用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为</li><li><p>协商缓存：用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源</p><p>两者共同点是客户端获得的数据最后都是从客户端缓存中获得。区别在于强缓存不与服务器交互，而协商缓存则需要与服务器交互。</p></li></ul><h4 id="IE-浏览器下的缓存问题"><a href="#IE-浏览器下的缓存问题" class="headerlink" title="IE 浏览器下的缓存问题"></a>IE 浏览器下的缓存问题</h4><p>IE 浏览器会缓存网页中的 GET 和 XHR 的内容，并且在 IE 浏览器中如果请求方式是 GET 的话，IE 浏览器会对其进行标识，如果该 GET 请求的 URL 是第一次请求的话，会请求相关服务器，从数据库中获取数据；而如果该 GETt 请求的 URL 不是第一次请求的话，IE 浏览器会直接从缓存副本中拿到上次该 URL 获取的数据。并且无论是形式封装的 GET 方式请求，IE 浏览器都会这样进行处理的。这对于实时性有要求的数据不适用，产生网页中的数据与数据库的数据不同步的现象。</p><h4 id="几种解决上述问题的方法"><a href="#几种解决上述问题的方法" class="headerlink" title="几种解决上述问题的方法"></a>几种解决上述问题的方法</h4><p>(1) GET 参数中添加一个随机数或当前时间戳的参数</p><p>保证每次 URL 请求唯一性，迫使每个 GET 请求都是一次新请求，这种方式虽然能解决 IE 始终返回 304 的问题，但实际上每个 request 都会去请求服务器，对 web 优化并非最佳的解决方案。</p><p>(2) 请求方式修改为 post 方法</p><p> 这种做法不符合 RESTful web API 设计，同时这种方式也会每次请求服务器，没有真正利用到 IE 的缓存机制。</p><p>(3) 在 HTML 页面设置 Meta 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-store"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> 这种禁用缓存的形式用处很有限：仅有 IE 才能识别这段 meta 标签含义，其它主流浏览器仅识别“Cache-Control: no-store”的 meta 标签；在 IE 中识别到该 meta 标签含义，只能保证请求当前 HTML 页面时每次都发新请求，网页上的资源则不受影响；因浏览器不同或者同一浏览器间版本不同，此方法存在很大的兼容性问题。</p><p>(4) 使用缓存有关的 HTTP 消息报头控制（协商缓存）</p><ul><li><p><strong>Cache-Control 与 Expires</strong></p><p> Cache-Control 与 Expires 的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。相比较 Cache-Control 的选择更多，设置更细致，如同时设置，其优先级高于 Expires。</p></li><li><p><strong>Last-Modified/ETag 与 Cache-Control/Expires</strong></p><p> 配置 Last-Modified/ETag 的情况下，浏览器再次访问该 URI 的资源，仍会发送请求到服务器询问文件是否已经修改。如未修改，服务器会只发送一个 304 回给浏览器，告诉浏览器直接从本地的缓存取数据；如已修改就返回修改过的数据。</p><p> Cache-Control/Expires 则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器会直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires 的优先级要高于 Last-Modified/ETag。</p><p> 一般情况下，使用 Cache-Control/Expires 会配合 Last-Modified/ETag 一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag 将能够很好利用 304，从而减少响应开销。</p></li><li><p><strong>Last-Modified 与 ETag</strong></p><p> Etag（实体标识）的出现主要是为了解决几个 Last-Modified 比较难解决的问题：首先，Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度。其次，如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存。</p><p> Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified 与 ETag 一起使用时，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p></li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p> <a href="https://www.cnblogs.com/shixiaomiao1122/p/7591556.html" target="_blank" rel="noopener">彻底理解浏览器缓存机制</a></p><p> <a href="https://www.cnblogs.com/slly/p/6732749.html" target="_blank" rel="noopener">浏览器缓存机制详解</a></p><p> <a href="https://blog.csdn.net/xiaoping0915/article/details/79145234" target="_blank" rel="noopener">IE 浏览器 GET 请求缓存问题</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;h4 id=&quot;什么是浏览器缓存，为什么要使用它？&quot;&gt;&lt;a href=&quot;#什么是浏览器缓存，为什么要使用它？&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器缓存，为什么要使用它？&quot;&gt;&lt;/a&gt;什么是浏览器缓存，为什么要使用它？&lt;/h4&gt;&lt;p&gt; 缓存游走于服务器和客户端之间。服务器可能是源服务器（存放请求资源的服务器），也可能是反向代理服务器（如 Nginx），数量为 1 个或多个；客户端可能为 PC 端、移动端等，数量也为 1 个或多个。简单的说，缓存用于监控服务器与客户端之间的通信，监控客户端请求，并且把请求输出的内容（如页面、 图片和文件）拷贝一份副本存在本地；然后，如果下一个请求是相同的 URL，则直接请求保存的副本，而不用再次向服务器获取。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tanyioo.github.io/blog/categories/Web/"/>
    
    
      <category term="浏览器缓存" scheme="https://tanyioo.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Blog Testing</title>
    <link href="https://tanyioo.github.io/blog/2018/10/13/Initial%20Test/"/>
    <id>https://tanyioo.github.io/blog/2018/10/13/Initial Test/</id>
    <published>2018-10-13T07:11:26.000Z</published>
    <updated>2019-07-11T01:47:38.950Z</updated>
    
    <content type="html"><![CDATA[<p class="description"> Shared mutable state is the root of all evil  –Pete Hunt</p><p><img src="https://github.com/tanyioO/image-lib/raw/master/blog/initialTest/test.jpg" alt="test"></p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt; Shared mutable state is the root of all evil  –Pete Hunt&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/tanyioO/image-lib/raw/master/blog/initialTest/test.jpg&quot; alt=&quot;test&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
